/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
/*                                                                           */
/*                  This file is part of the program and library             */
/*         SCIP --- Solving Constraint Integer Programs                      */
/*                                                                           */
/*    Copyright (C) 2002-2005 Tobias Achterberg                              */
/*                                                                           */
/*                  2002-2005 Konrad-Zuse-Zentrum                            */
/*                            fuer Informationstechnik Berlin                */
/*                                                                           */
/*  SCIP is distributed under the terms of the SCIP Academic License.        */
/*                                                                           */
/*  You should have received a copy of the SCIP Academic License             */
/*  along with SCIP; see the file COPYING. If not email to scip@zib.de.      */
/*                                                                           */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
#pragma ident "@(#) $Id: ReaderTSP.cpp,v 1.1 2005/04/14 19:05:05 bzfberth Exp $"

/**@file   ReaderTSP.cpp
 * @brief  C++ file reader for TSP data files
 * @author Timo Berthold
 */

/*---+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8----+----9----+----0----+----1----+----2*/

#include <iostream>
#include <fstream>
#include <string>
#include <sstream>

extern "C" {
#include "scip/cons_linear.h"
}

#include "ReaderTSP.h"
#include "ProbDataTSP.h"
#include "ConshdlrSubtour.h"
#include "GomoryHuTree.h"

using namespace tsp;
using namespace scip;
using namespace std;

/** parses the node list */ 
void ReaderTSP::getNodesFromFile(
   std::ifstream&    filedata,       /**< filestream containing the data to extract */
   double*           x_coords,       /**< double array to be filled with the x-coordinates of the nodes */
   double*           y_coords,       /**< same for y-coordinates */
   GRAPH*            graph           /**< the graph which is to be generated by the nodes */
   )
{
   int i=0;
   int nodenumber;
   GRAPHNODE* node = &(graph->nodes[0]);

   // extract every node out of the filestream
   while ( i < graph->nnodes && !filedata.eof() )
   {
      filedata >> nodenumber >> x_coords[i] >> y_coords[i];

      // assign everything 
      node->id = i;
      if( nodenumber-1 != i)
         cout<<"warning: nodenumber <" <<nodenumber<<"> does not match its index in node list <"<<i+1
             <<">. Node will get number "<<i+1<<" when naming variables and constraints!"<<endl;
      node->x = x_coords[i];
      node->y = y_coords[i];
      node->first_edge = NULL; 
      node++; 
      i++;
   }
   assert( i == graph->nnodes );
}

/**< method asserting, that the file has had the correct format and everything was set correctly */
bool ReaderTSP::checkValid(
   GRAPH*         graph,             /**< the constructed graph, schould not be NULL */ 
   std::string    name,              /**< the name of the file */
   std::string    type,              /**< the type of the problem, should be "TSP" */
   std::string    edgeweighttype,    /**< type of the edgeweights, should be "EUC_2D", "MAX_2D", or "MAN_2D" */
   int            nnodes             /**< dimension of the problem, should at least be one */
   )
{   
   // if something seems to be strange, it will be reported, that file was not valid
   if( nnodes < 1 )
   {
      cout << "parse error in file <" << name << "> dimension should be greater than 0"<< endl ;
      return false;
   }
   if (type != "TSP" )
   {  
      cout << "parse error in file <" << name << "> type should be TSP" << endl;
      return false;
   }
   if ( !( edgeweighttype == "EUC_2D" || edgeweighttype == "MAX_2D" || edgeweighttype == "MAN_2D" ) )
   {
      cout << "parse error in file <" << name << "> unknown weight type, should be EUC_2D, MAX_2D, or MAN_2D" << endl;
      return false;
   }
   if( graph == NULL)
   {
      cout << "error while reading file <" << name << ">, graph is uninitialized. "; 
      cout << "Probably NODE_COORD_SECTION is missing" << endl;
      return false;
   }
   return true;
}


/** destructor of file reader to free user data (called when SCIP is exiting) */
RETCODE ReaderTSP::scip_free(
   SCIP*         scip,               /**< SCIP data structure */
   READER*       reader              /**< the file reader itself */
   )
{
   return SCIP_OKAY;
}

/** problem reading method of reader
 *
 *  possible return values for *result:
 *  - SCIP_SUCCESS    : the reader read the file correctly and created an appropritate problem
 *  - SCIP_DIDNOTRUN  : the reader is not responsible for given input file
 *
 *  If the reader detected an error in the input file, it should return with RETCODE SCIP_READERR or SCIP_NOFILE.
 */
RETCODE ReaderTSP::scip_read(
   SCIP*         scip,               /**< SCIP data structure */
   READER*       reader,             /**< the file reader itself */
   const char*   filename,           /**< full path and name of file to read, or NULL if stdin should be used */
   RESULT*       result              /**< pointer to store the result of the file reading call */
   )
{
   RETCODE retcode;

   GRAPH* graph = NULL;
   GRAPHNODE* node;
   GRAPHNODE* nodestart;             // the two incident nodes of an edge
   GRAPHNODE* nodeend;
   GRAPHEDGE* edgeforw;              // two converse halfedges
   GRAPHEDGE* edgebackw;
   GRAPHEDGE* edge;

   double* x_coords;                 // arrays of coordinates of the nodes
   double* y_coords;
   double x;                         // concrete coordinates
   double y;

   int nnodes = 0;
   int nedges;
   int i;
   int j;

   string name = "MY_OWN_LITTLE_TSP";
   string token;
   string type = "TSP";
   string edgeweighttype = "EUC_2D";

   retcode = SCIP_OKAY;
   *result = SCIP_DIDNOTRUN;

   // open the file
   ifstream filedata(filename);
   if( !filedata )
      return SCIP_READERROR;
       
   // read the first lines of information
   while( !filedata.eof() )
   {
      filedata >> token;
      if(token == "NAME:")
         filedata >> name;
      else if(token == "NAME")
         filedata >> token >> name;
      else if(token == "TYPE:")
         filedata >> type;
      else if(token == "TYPE")
         filedata >> token >> type;
      else if(token == "DIMENSION:")
      {
         filedata >> nnodes;
         nedges = nnodes * (nnodes-1);
      }
      else if(token == "DIMENSION")
      {
         filedata >> token >> nnodes;
         nedges = nnodes * (nnodes-1);
      }
      else if(token == "EDGE_WEIGHT_TYPE:")
         filedata >> edgeweighttype;
      else if(token == "EDGE_WEIGHT_TYPE")
         filedata >> token >> edgeweighttype;
      else if(token == "NODE_COORD_SECTION")
      {
         // there should be some nodes to construct a graph
         if(nnodes < 1)
         {
            retcode = SCIP_READERROR;
            break;
         }
         // the graph is created and filled with nodes 
         else if( create_graph(nnodes, nedges, &graph) )
         {
            CHECK_OKAY( SCIPallocBufferArray(scip, &x_coords, nnodes) );
            CHECK_OKAY( SCIPallocBufferArray(scip, &y_coords, nnodes) );
            getNodesFromFile(filedata, x_coords, y_coords, graph);
         }
         else
         {
            retcode = SCIP_NOMEMORY;
            break;
         }
      }
      else if( token == "COMMENT:" || token == "COMMENT" )
         getline( filedata, token ); 
      else if( token == "EOF" )
         break;
      else
      {
         cout << "parse error in file <" << name << "> unknown keyword <" << token << ">" << endl;
         return SCIP_READERROR;
      }
   }// finished parsing the input
   
   // check whether the input data was valid
   if( !checkValid(graph, name, type, edgeweighttype, nnodes) )
      retcode = SCIP_READERROR;

   if( retcode == SCIP_OKAY )
   {
      edgeforw = &( graph->edges[0] ); 
      edgebackw= &( graph->edges[nedges/2] );

      // construct all edges in a complete digraph
      for( i = 0; i < nnodes; i++ )
      {
         nodestart = &graph->nodes[i];
         for( j = i+1; j < nnodes; j++ )
         {
            nodeend = &graph->nodes[j];

            // construct two 'parallel' halfedges
            edgeforw->adjac = nodeend;
            edgebackw->adjac = nodestart;
            edgeforw->back = edgebackw;
            edgebackw->back = edgeforw;

            // calculate the Euclidean / Manhattan / Maximum distance of the two nodes
            x = x_coords[(*nodestart).id] -  x_coords[(*nodeend).id];
            y = y_coords[(*nodestart).id] -  y_coords[(*nodeend).id];
            if( edgeweighttype == "EUC_2D")
               edgeforw->length = SQRT( x*x + y*y );
            else if ( edgeweighttype == "MAX_2D")
               edgeforw->length = MAX( ABS(x), ABS(y) );
            else if ( edgeweighttype == "MAN_2D")
               edgeforw->length =  ABS(x) + ABS(y);

            // in TSP community, it is common practice to round lengths to next integer
            if( round_lengths_ )
               edgeforw->length = SCIPfloor(scip, edgeforw->length+0.5);
            
            edgebackw->length = edgeforw->length;
         
            // insert one of the halfedges into the edge list of the node
            if (nodestart->first_edge == NULL)
            {
               nodestart->first_edge = edgeforw;
               nodestart->first_edge->next = NULL;
            }
            else
            {
               edgeforw->next = nodestart->first_edge;
               nodestart->first_edge = edgeforw;
            }
                   
            // dito
            if (nodeend->first_edge == NULL)
            {
               nodeend->first_edge = edgebackw;
               nodeend->first_edge->next = NULL;
            }
            else
            {
               edgebackw->next = nodeend->first_edge;
               nodeend->first_edge = edgebackw;
            }           
                     
            edgeforw++;
            edgebackw++;            
         }
      }
   }

   SCIPfreeBufferArray(scip, &y_coords);
   SCIPfreeBufferArray(scip, &x_coords);
   
   if( retcode != SCIP_OKAY )
      return retcode;

   // create the problem's data structure
   CHECK_OKAY( SCIPcreateObjProb(scip, name.c_str(), new ProbDataTSP(graph), TRUE) );

   // add variables to problem and link them for parallel halfedges
   for( i = 0; i < nedges/2; i++ )
   {
      stringstream varname;
      edge = &graph->edges[i];

      // the variable is named after the two nodes connected by the edge it represents
      varname << "x_e_" << edge->back->adjac->id+1 << "-" << edge->adjac->id+1;
      CHECK_OKAY( SCIPcreateVar(scip, &edge->var, varname.str().c_str(), 0.0, 1.0, edge->length,
            SCIP_VARTYPE_BINARY, TRUE, FALSE, NULL, NULL, NULL, NULL) );
      
      //two parallel halfedges have the same variable
      edge->back->var = edge->var;
      CHECK_OKAY( SCIPcaptureVar(scip, edge->var) );
      CHECK_OKAY( SCIPaddVar(scip, edge->var) );
   }

   // add all n node degree constraints
   if( nnodes >= 2 )
   {
      for( i = 0, node = &(graph->nodes[0]); i < nnodes; i++, node++ )
      {
         CONS* cons;
         stringstream consname;
         consname << "deg_con_v" << node->id+1;
         
         // a new degree constraint is created, named after a node
         CHECK_OKAY( SCIPcreateConsLinear(scip, &cons, consname.str().c_str(), 0, NULL, NULL, 2.0, 2.0, 
               TRUE, FALSE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE) );  

         edge = node->first_edge;
         // sum up the values of all adjacent edges 
         while( edge != NULL )
         {
            CHECK_OKAY( SCIPaddCoefLinear(scip, cons, edge->var, 1.0) );
            edge = edge->next;
         }
             
         // add the constraint to SCIP
         CHECK_OKAY( SCIPaddCons(scip, cons) );
         CHECK_OKAY( SCIPreleaseCons(scip, &cons) );
      }
   }

   // last, we need a constraint forbidding subtours
   CONS* cons;
   CHECK_OKAY( SCIPcreateConsSubtour(scip, &cons, "subtour", graph, FALSE, TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, TRUE ) ); /* aus cons_subtour.h; eigener Constraint Handler */
   CHECK_OKAY( SCIPaddCons(scip, cons) );
   CHECK_OKAY( SCIPreleaseCons(scip, &cons) );
 
   release_graph(&graph);
   *result = SCIP_SUCCESS;

   return SCIP_OKAY;
}

